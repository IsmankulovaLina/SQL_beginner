В заданиях данного дня допустимо использовать синтаксисы SQL, DML, DDL

## Exercise 00 — Скидки, скидки, все любят скидки  
Давайте добавим новую бизнес-функцию в нашу модель данных.  
Каждый человек хочет видеть личную скидку, а каждый бизнес — быть ближе к клиентам.  

Подумайте о личных скидках для людей с одной стороны и пиццериях с другой. Необходимо создать новую реляционную таблицу (пожалуйста, задайте имя `person_discounts`) с следующими правилами:  
- Установите атрибут `id` как первичный ключ (пожалуйста, посмотрите на столбец `id` в существующих таблицах и выберите тот же тип данных).  
- Установите атрибуты `person_id` и `pizzeria_id` как внешние ключи для соответствующих таблиц (тип данных должен быть таким же, как у столбцов `id` в соответствующих родительских таблицах).  
- Пожалуйста, задайте явные имена для ограничений внешних ключей, используя шаблон `fk_{table_name}_{column_name}`, например `fk_person_discounts_person_id`.  
- Добавьте атрибут `discount`, чтобы хранить значение скидки в процентах. Помните, что значение скидки может быть числом с плавающей точкой (просто используйте тип данных `numeric`). Поэтому выберите подходящий тип данных для учета этой возможности.  

## Exercise 01 — Давайте установим личные скидки  
На самом деле, мы создали структуру для хранения наших скидок и готовы двигаться дальше и заполнять таблицу `person_discounts` новыми записями.  

Итак, есть таблица `person_order`, которая хранит историю заказов человека. Пожалуйста, напишите DML-запрос (`INSERT INTO ... SELECT ...`), который вставляет новые записи в таблицу `person_discounts` согласно следующим правилам:  
- Используйте агрегированное состояние по столбцам `person_id` и `pizzeria_id`.  
- Рассчитайте значение личной скидки по следующему псевдокоду:  

    ```sql
    if “количество заказов” = 1 then
        “скидка” = 10.5
    else if “количество заказов” = 2 then
        “скидка” = 22
    else
        “скидка” = 30
    ```  

- Для создания первичного ключа таблицы `person_discounts` используйте следующий SQL-конструкт:  

    ```sql
    ... ROW_NUMBER() OVER ( ) AS id ...
    ```  

## Exercise 02 — Пересчитаем историю заказов  
Напишите SQL-запрос, который возвращает заказы с актуальной ценой и ценой с примененной скидкой для каждого человека в соответствующем ресторане пиццерии, отсортированный по имени человека и названию пиццы. Ниже приведены примерные данные.  

| name | pizza_name | price | discount_price | pizzeria_name |  
| ------ | ------ | ------ | ------ | ------ |  
| Andrey | cheese pizza | 800 | 624 | Dominos |  
| Andrey | mushroom pizza | 1100 | 858 | Dominos |  
| ... | ... | ... | ... | ... |

## Exercise 03 — Улучшения в дороге  
На самом деле нам нужно улучшить согласованность данных с одной стороны и оптимизацию производительности с другой стороны. Пожалуйста, создайте мультиколоночный уникальный индекс (с именем `idx_person_discounts_unique`), который предотвращает дублирование пар идентификаторов человека и пиццерии.  

После создания нового индекса предоставьте любой простой SQL-запрос, показывающий использование индекса (используя `EXPLAIN ANALYZE`).  
Пример доказательства:  

    ...
    Index Scan using idx_person_discounts_unique on person_discounts
    ...

## Exercise 04 — Нам нужна большая согласованность данных  
Пожалуйста, добавьте следующие ограничения для существующих столбцов таблицы `person_discounts`:  
- Столбец `person_id` не должен быть NULL (используйте имя ограничения `ch_nn_person_id`)  
- Столбец `pizzeria_id` не должен быть NULL (используйте имя ограничения `ch_nn_pizzeria_id`)  
- Столбец `discount` не должен быть NULL (используйте имя ограничения `ch_nn_discount`)  
- Значение по умолчанию для столбца `discount` должно быть равно 0 процентов;  
- Значение в диапазоне от 0 до 100 (используйте имя ограничения `ch_range_discount`).  

## Exercise 05 — Правила управления данными  
Чтобы соответствовать политикам управления данными, необходимо добавить комментарии к таблице и её столбцам. Применим эту политику к таблице `person_discounts`. Пожалуйста, добавьте комментарии на английском или русском языке (выбирайте сами), объясняющие бизнес-цель таблицы и всех её атрибутов.  

## Exercise 06 — Автоматизация генерации первичного ключа  
Создайте последовательность базы данных с именем `seq_person_discounts` (начинающуюся со значения 1) и установите значение по умолчанию для атрибута `id` таблицы `person_discounts`, чтобы оно автоматически получало значение из последовательности при каждом добавлении новой записи. Не используйте жестко закодированное число строк для установки правильного значения последовательности.  
  
Обратите внимание: ваше следующее число последовательности равно 1; в этом случае установите актуальное значение последовательности на основе формулы "число строк в таблице person_discounts" + 1. Иначе вы получите ошибку нарушения ограничения первичного ключа.
